<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Default Title - Page specific templates will override this -->
    <title>{{ block "title" . }}EasyToList{{ end }}</title>

    <!-- Common CSS -->
    <link rel="stylesheet" href="/static/styles.css"> <!-- Your main CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css">

    <!-- Placeholder for page-specific CSS or meta tags -->
    {{ block "head_extra" . }}{{ end }}

</head>
<body>

    <!-- Loading Overlay (Common) -->
    <div id="loadingOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.8); z-index: 1000; text-align: center;">
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
        <img src="/static/spinner.gif" alt="Loading..." style="width:50px; height:50px;">
        <p style="font-size: 16px; color: #333;">Loading...</p>
      </div>
    </div>

    <!-- Include Header Partial -->
    {{ template "header" . }}

   <!-- Search Bar Section (Can be overridden) -->
    {{ block "search_section" . }}
    {{ if .ShowSearchCategorySections }}
        {{ template "search_bar" . }}
    {{ end }}
    {{ end }}

    <!-- Category Browse Section (Can be overridden) -->
    {{ block "category_browse_section" . }}
    {{ if .ShowSearchCategorySections }}
        {{ template "category_browse" . }}
    {{ end }}
    {{ end }}

    <!-- Main Content Block - Page specific templates fill this -->
    {{ block "content" . }}
        <!-- Default content if a page doesn't define this block -->
    {{ end }}

    <!-- Include Footer Partial -->
    {{ template "footer" . }}

    <!-- ====================================================== -->
    <!--                  START COMMON JAVASCRIPT               -->
    <!-- ====================================================== -->

    <!-- Common JS Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>

    <!-- Combined JavaScript Logic -->
    <script>
    /********************************************************
     *                                                      *
     *         GLOBAL VARIABLES & CONFIGURATION             *
     *     (Needed by Search, Categories, potentially others) *
     *                                                      *
     ********************************************************/

    const subcategories = {
      mobile: ['Smartphones', 'Basic Phones', 'Mobile Accessories', 'Tablets & iPads'],
      jobs: ['Full-Time Jobs', 'Part-Time Jobs', 'Freelance & Remote Jobs', 'Internship & Traineeships', 'Work from Home', 'Government Jobs', 'Teaching & Education', 'IT & Software Jobs', 'Customer Service Jobs', 'Marketing & Sales Jobs'],
      real_estate: ['Apartments for Rent', 'Houses for Rent', 'Offices & Shops for Rent', 'Houses for Sale', 'Apartments for Sale', 'Land & Plots', 'Commercial Properties'],
      vehicle: ['Cars', 'Motorcycles', 'Trucks & Commercial Vehicles', 'Bicycles', 'Boats & Watercraft', 'Auto Parts & Accessories', 'Rental Vehicles'],
      electronics: ['Laptops & Computers', 'Computer Accessories', 'Cameras & Photography', 'TVs, Audio & Video', 'Home Appliances', 'Kitchen Appliances', 'Gaming Consoles & Accessories'],
      education: ['Online Courses', 'Professional Certifications', 'Language Classes'],
      personal: ['Men Seeking Women', 'Women Seeking Men', 'Men Seeking Men', 'Women Seeking Women', 'Friendship & Companionship', 'Casual Encounters', 'Long-Term Relationships', 'Marriage Proposals', 'Sugar Dating'],
      home: ['Sofas & Dining Sets', 'Beds & Wardrobes', 'Home Decor', 'Office Furniture', 'Outdoor Furniture'],
      fashion: ['Men’s Clothing', 'Women’s Clothing', 'Kids’ Clothing', 'Watches & Accessories', 'Skincare & Beauty Products', 'Shoes & Footwear'],
      services: ['Home Repair & Maintenance', 'Moving & Transport Services', 'Tutors & Coaching', 'Web & IT Services', 'Travel & Tourism', 'Legal & Financial Services', 'Event Planning'],
      pets: ['Dogs', 'Cats', 'Birds', 'Fish & Aquariums', 'Pet Accessories', 'Pet Adoption'],
      sports: ['Gym & Fitness Equipment', 'Musical Instruments', 'Books & Magazines', 'Collectibles & Antiques', 'Camping & Outdoor Gear'],
      kids: ['Toys & Games', 'Baby Clothing', 'Baby Gear (Strollers, Car Seats)'],
      agriculture: ['Tractors & Machinery', 'Seeds & Plants', 'Fertilizers & Pesticides', 'Livestock'],
      business: ['Office Supplies', 'Industrial Equipment', 'Wholesale & Bulk Items']
    };

    const PAGE_SIZE = 16;
    const CATEGORY_PAGE_SIZE = 16;
    let initialLoadPage = 1;
    let currentFilterPage = 1;
    let currentFilterParams = null;
    let categoryCurrentPage = 1;
    let currentSubcategoryFilter = null; // Stores { category: '...', subcategory: '...' }

    /********************************************************
     *                                                      *
     *                 UTILITY FUNCTIONS                    *
     *    (Carousel, Ad Card Creation, Location, etc.)      *
     *      (Needed by Index, Search, Categories)           *
     ********************************************************/

     // Function to initialize carousel for an ad card
    function setupCarousel(carousel) {
      if (!carousel || carousel.dataset.initialized) return;
      const inner = carousel.querySelector('.carousel-inner');
      const items = carousel.querySelectorAll('.carousel-item');
      const dotsContainer = carousel.querySelector('.carousel-dots');
      const dots = dotsContainer ? dotsContainer.querySelectorAll('.dot') : [];
      let currentIndex = 0;
      if (!inner || items.length <= 1) { if(dotsContainer) dotsContainer.style.display = 'none'; carousel.dataset.initialized = true; return; }
      if(dotsContainer && dots.length > 0) dotsContainer.style.display = 'flex';
      dots.forEach((dot, index) => { dot.addEventListener('click', (e) => { e.stopPropagation(); currentIndex = index; updateCarousel(); }); });
      let touchStartX = 0;
      carousel.addEventListener('touchstart', (e) => { touchStartX = e.touches[0].clientX; }, { passive: true });
      carousel.addEventListener('touchend', (e) => { const touchEndX = e.changedTouches[0].clientX; const diff = touchStartX - touchEndX; if (Math.abs(diff) > 50) { if (diff > 0 && currentIndex < items.length - 1) { currentIndex++; } else if (diff < 0 && currentIndex > 0) { currentIndex--; } updateCarousel(); } });
      function updateCarousel() { inner.style.transform = `translateX(-${currentIndex * 100}%)`; dots.forEach((dot, i) => { dot.classList.toggle('active', i === currentIndex); }); }
      carousel.dataset.initialized = true;
    }

    // Function to create ad card HTML element (REUSED by Index, Search, Categories)
    function createAdCard(ad) {
      const adCard = document.createElement('div'); adCard.className = 'ad-card';
      const imagePaths = ad.image_paths || ad.ImagePaths || []; const adId = ad.id || ad.ID; const adTitle = ad.title || ad.Title || 'Untitled Ad'; const adCity = ad.city || ad.City || 'N/A'; const adState = ad.state || ad.State || 'N/A'; const adCategory = ad.category || ad.Category || 'N/A'; const adSubcategory = ad.subcategory || ad.Subcategory || 'N/A'; const adPrice = ad.price !== undefined && ad.price !== null ? ad.Price || ad.price : null; const formattedPrice = (adPrice !== null) ? `₹${parseFloat(adPrice).toLocaleString('en-IN')}` : 'Price N/A';
      const imagesHTML = imagePaths.length > 0 ? imagePaths.map((img, index) => `<div class="carousel-item ${index === 0 ? 'active' : ''}"><img src="/uploads/${img}" alt="Ad Image" loading="lazy"></div>`).join('') : `<div class="carousel-item active"><img src="/static/default-image.jpg" alt="No Image"></div>`;
      const dotsHTML = imagePaths.length > 1 ? `<div class="carousel-dots">${imagePaths.map((_, index) => `<span class="dot ${index === 0 ? 'active' : ''}" data-index="${index}"></span>`).join('')}</div>` : '';
      adCard.innerHTML = `<div class="carousel" data-ad-id="${adId}"><div class="carousel-inner">${imagesHTML}</div> ${dotsHTML}</div><a href="/ad/${adId}" class="ad-card-wrapper"><div class="ad-content"><h2 class="ad-title">${adTitle}</h2><p class="location"><img src="/static/locationicon.png" alt="Location" class="location-pin-icon"> <span>${adCity}, ${adState}</span></p><p class="category-info"><span class="category-tag">${adCategory.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</span> • <span class="subcategory-tag">${adSubcategory.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</span></p><div class="divider"></div><div class="price-section"> <span class="price">${formattedPrice}</span> <img src="/static/pageopenicon.png" alt="View" class="view-icon"> </div></div></a>`;
      return adCard;
    }

    // Function to update the MAIN ads grid (used by Search Filters, possibly Index initial load if done via JS)
    function updateAdsGrid(ads) {
      const mainAdsGrid = document.querySelector('main.container > section.ads-grid'); const mainShowMoreBtn = document.getElementById('showMoreBtn'); const categoryResultsContainer = document.getElementById('categoryResultsContainer');
      if (!mainAdsGrid) { console.warn("Main ads grid not found on this page for update."); return; } // Use warn, not error
      if (categoryResultsContainer) categoryResultsContainer.style.display = 'none'; // Hide category results when main grid updates
      mainAdsGrid.innerHTML = '';
      if (!ads || ads.length === 0) { mainAdsGrid.innerHTML = '<p style="text-align: center; grid-column: 1 / -1;">No ads found matching your criteria.</p>'; if (mainShowMoreBtn) mainShowMoreBtn.style.display = 'none'; return; }
      ads.forEach(ad => { const adCard = createAdCard(ad); mainAdsGrid.appendChild(adCard); setupCarousel(adCard.querySelector('.carousel')); });
      if (mainShowMoreBtn) { mainShowMoreBtn.style.display = (ads.length < PAGE_SIZE) ? 'none' : 'block'; mainShowMoreBtn.disabled = false; mainShowMoreBtn.textContent = 'Show More'; }
    }

    // Function to append ads to the MAIN grid (used by Index Show More, possibly Filter Show More)
    function appendAdsToGrid(ads) {
       const mainAdsGrid = document.querySelector('main.container > section.ads-grid'); const mainShowMoreBtn = document.getElementById('showMoreBtn');
       if (!mainAdsGrid) { console.warn("Main ads grid not found on this page for appending."); return; } // Use warn
       if (!ads || ads.length === 0) { if (mainShowMoreBtn) mainShowMoreBtn.style.display = 'none'; return; }
       ads.forEach(ad => { const adCard = createAdCard(ad); mainAdsGrid.appendChild(adCard); setupCarousel(adCard.querySelector('.carousel')); });
       if (mainShowMoreBtn) { mainShowMoreBtn.style.display = (ads.length < PAGE_SIZE) ? 'none' : 'block'; mainShowMoreBtn.disabled = false; mainShowMoreBtn.textContent = 'Show More'; }
    }

    // Function to fetch lat/lng via forward geocoding (Used by Search)
    function fetchAndUpdateLatLng(state, pincode) {
      return new Promise((resolve) => {
        const latInput = document.getElementById('latInput'); const lngInput = document.getElementById('lngInput');
        if (!latInput || !lngInput) { console.error("Lat/Lng input fields not found"); resolve({ lat: "", lng: "" }); return; }
        if (!state || !pincode) { latInput.value = ""; lngInput.value = ""; console.log("State or Pincode missing, skipping forward geocode."); resolve({ lat: "", lng: "" }); return; }
        console.log(`Attempting forward geocode for State: ${state}, Pincode: ${pincode}`);
        fetch(`/forward-geocode?state=${encodeURIComponent(state)}&pincode=${encodeURIComponent(pincode)}`)
          .then(response => { if (!response.ok) { return response.text().then(text => { throw new Error(`Geocoding HTTP error! Status: ${response.status}. Response: ${text}`); }); } return response.json(); })
          .then(data => { if (data.lat && data.lng) { latInput.value = data.lat; lngInput.value = data.lng; console.log("Forward geocode successful. Updated lat/lng:", data.lat, data.lng); resolve({ lat: data.lat, lng: data.lng }); } else { latInput.value = ""; lngInput.value = ""; console.error("Forward geocoding failed: No lat/lng in response. Message: " + (data.error || 'Unknown reason'), data); resolve({ lat: "", lng: "" }); } })
          .catch(error => { console.error("Forward geocoding fetch/processing error:", error); latInput.value = ""; lngInput.value = ""; resolve({ lat: "", lng: "" }); });
      });
    }

    // Function to handle location logic (Used by Search and potentially Categories on load)
    function handleLocationLogic(showAlerts = true) {
        const latInput = document.getElementById('latInput');
        const lngInput = document.getElementById('lngInput');
        const stateInput = document.getElementById('stateInput');
        const pincodeInput = document.getElementById('pincodeInput');
        const loadingOverlay = document.getElementById('loadingOverlay');

        // Check if the necessary *input* elements for *this function's primary purpose* exist
        // (Mainly for the search bar interaction)
        if (!latInput || !lngInput || !stateInput || !pincodeInput) {
            // console.log("handleLocationLogic: Skipping execution as required search/category inputs (latInput, lngInput, stateInput, pincodeInput) were not found on this page.");
            return; // Exit silently if these specific inputs aren't there
        }

        // If inputs exist, ensure the loading overlay also exists
        if (!loadingOverlay) {
            console.error("handleLocationLogic: The loadingOverlay element was not found, cannot proceed.");
            return;
        }

        // Proceed with geolocation if inputs and overlay are present
        if (navigator.geolocation) {
            loadingOverlay.style.display = 'block';
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    latInput.value = lat; // Safe to use now
                    lngInput.value = lng; // Safe to use now
                    console.log("Geolocation success. Lat:", lat, "Lng:", lng);

                    fetch(`/geocode?lat=${lat}&lng=${lng}`)
                        .then(response => response.ok ? response.json() : response.text().then(text => Promise.reject(new Error(`Reverse geocode HTTP error! Status: ${response.status}. Response: ${text}`))))
                        .then(data => {
                            if (data.status === "OK" && data.state && data.pincode) {
                                // Only update if showing alerts OR if the field is currently empty
                                if (showAlerts || !stateInput.value) { stateInput.value = data.state; } // Safe to use now
                                if (showAlerts || !pincodeInput.value) { pincodeInput.value = data.pincode; } // Safe to use now
                                console.log("Reverse geocode success. State:", data.state, "Pincode:", data.pincode);
                            } else {
                                console.error("Reverse geocoding failed or missing data:", data);
                                if (showAlerts) {
                                    stateInput.value = ''; // Safe to use now
                                    pincodeInput.value = ''; // Safe to use now
                                    alert("Could not determine State/Pincode from location.");
                                }
                            }
                        })
                        .catch(error => {
                            console.error("Reverse geocoding fetch/processing error:", error);
                            if (showAlerts) {
                                stateInput.value = ''; // Safe to use now
                                pincodeInput.value = ''; // Safe to use now
                                alert(`Error determining State/Pincode: ${error.message}.`);
                            }
                        })
                        .finally(() => {
                            loadingOverlay.style.display = 'none';
                        });
                },
                (error) => {
                    console.error("Error getting geolocation:", error.message, `(Code: ${error.code})`);
                    let msg = "Unable to get location.";
                    if (error.code === 1) { msg = "Location access denied."; }
                    else if (error.code === 2) { msg = "Location information unavailable."; }
                    else if (error.code === 3) { msg = "Location request timed out."; }

                    if (showAlerts) {
                        alert(msg + " Please allow access or enter manually.");
                    } else {
                        console.warn("Auto-fetch location failed:", msg);
                    }

                    // Clear inputs only if showing alerts (and inputs exist)
                    if (showAlerts) {
                        latInput.value = ''; // Safe to use now
                        lngInput.value = ''; // Safe to use now
                        stateInput.value = ''; // Safe to use now
                        pincodeInput.value = ''; // Safe to use now
                    }
                    loadingOverlay.style.display = 'none';
                },
                { timeout: 10000, enableHighAccuracy: true }
            );
        } else {
            if (showAlerts) {
                alert("Geolocation is not supported by this browser.");
            } else {
                console.warn("Geolocation not supported by browser.");
            }
            loadingOverlay.style.display = 'none';
        }
    } // End of handleLocationLogic function

    /********************************************************
     *                                                      *
     *    CATEGORY/SUBCATEGORY RESULT HANDLING FUNCTIONS    *
     *            (Used by Category Browse)                 *
     *                                                      *
     ********************************************************/

    // Function to update the CATEGORY ads grid (Populates #categoryAdsGrid)
    function updateCategoryAdsGrid(ads) {
        const adsGrid = document.getElementById('categoryAdsGrid');
        const showMoreBtn = document.getElementById('categoryShowMoreBtn');
        const resultsContainer = document.getElementById('categoryResultsContainer');
        const resultsHeading = document.getElementById('categoryResultsHeading');
        if (!adsGrid || !showMoreBtn || !resultsContainer || !resultsHeading) {
            console.warn("One or more category results elements are missing on this page!");
            return;
        }
        adsGrid.innerHTML = ''; // Clear previous ads
        let subcatDisplay = currentSubcategoryFilter?.subcategory?.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Selected Subcategory';
        let catDisplay = currentSubcategoryFilter?.category?.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Selected Category';

        if (!ads || ads.length === 0) {
            adsGrid.innerHTML = '<p style="text-align: center; grid-column: 1 / -1; padding: 20px;">No ads found for this subcategory near you.</p>';
            showMoreBtn.style.display = 'none';
            resultsHeading.textContent = `No Results for ${subcatDisplay} in ${catDisplay}`;
            resultsContainer.style.display = 'block'; // Show the container even if no results
            return;
        }

        resultsHeading.textContent = `Showing Ads for ${subcatDisplay} in ${catDisplay}`;
        ads.forEach(ad => {
            const adCard = createAdCard(ad);
            adsGrid.appendChild(adCard);
            setupCarousel(adCard.querySelector('.carousel')); // Setup carousel for new cards
        });

        resultsContainer.style.display = 'block'; // Show results container
        // Show/hide "Show More" button based on results length
        showMoreBtn.style.display = (ads.length < CATEGORY_PAGE_SIZE) ? 'none' : 'inline-block';
        showMoreBtn.disabled = false;
        showMoreBtn.textContent = 'Show More';
    }

    // Function to append ads to the CATEGORY grid (Appends to #categoryAdsGrid)
    function appendCategoryAdsGrid(ads) {
        const adsGrid = document.getElementById('categoryAdsGrid');
        const showMoreBtn = document.getElementById('categoryShowMoreBtn');
        if (!adsGrid || !showMoreBtn) {
            console.warn("Category grid or show more button missing for append on this page!");
            return;
        }
        if (!ads || ads.length === 0) {
            showMoreBtn.style.display = 'none'; // No more ads, hide button
            return;
        }
        ads.forEach(ad => {
            const adCard = createAdCard(ad);
            adsGrid.appendChild(adCard);
            setupCarousel(adCard.querySelector('.carousel')); // Setup carousel for appended cards
        });
        // Update "Show More" button visibility
        showMoreBtn.style.display = (ads.length < CATEGORY_PAGE_SIZE) ? 'none' : 'inline-block';
        showMoreBtn.disabled = false;
        showMoreBtn.textContent = 'Show More';
    }

    // Function to fetch ads for a specific subcategory via /fetch-by-subcategory
    function fetchCategoryAds(category, subcategory, lat, lng, page) {
        const showMoreBtn = document.getElementById('categoryShowMoreBtn');
        const adsGrid = document.getElementById('categoryAdsGrid');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const resultsContainer = document.getElementById('categoryResultsContainer');
        const resultsHeading = document.getElementById('categoryResultsHeading');

        // Ensure all required elements exist
        if (!showMoreBtn || !adsGrid || !loadingOverlay || !resultsContainer || !resultsHeading) {
            console.warn("Missing required elements for fetchCategoryAds on this page");
            return;
        }
        // Validate inputs
        if (!category || !subcategory) {
            console.error("Category or Subcategory missing for fetch.");
            resultsContainer.style.display = 'none'; // Hide potentially stale results
            return;
        }
        if (!lat || !lng) {
            // Alert the user if location is missing (it's required for subcategory search)
            alert("Location (latitude/longitude) is required to search by subcategory.\nPlease allow location access or use the location icon in the search bar.");
            resultsContainer.style.display = 'none';
            return;
        }

        console.log(`Fetching page ${page} for Cat: ${category}, Sub: ${subcategory}, Loc: ${lat},${lng}`);
        loadingOverlay.style.display = 'block'; // Show loading overlay

        // UI updates based on whether it's the first page load or "Show More"
        if (page === 1) {
            adsGrid.innerHTML = '<p style="text-align: center; grid-column: 1 / -1; padding: 20px;">Loading ads...</p>'; // Initial loading message
            resultsHeading.textContent = 'Loading...';
            resultsContainer.style.display = 'block'; // Show container immediately
            showMoreBtn.style.display = 'none'; // Hide button initially
        } else {
            showMoreBtn.textContent = 'Loading...'; // Update button text for "Show More"
            showMoreBtn.disabled = true;
        }

        const fetchUrl = `/fetch-by-subcategory?category=${encodeURIComponent(category)}&subcategory=${encodeURIComponent(subcategory)}&lat=${lat}&lng=${lng}&page=${page}`;

        fetch(fetchUrl, { method: 'GET' })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        throw new Error(`Failed: ${response.statusText} (${response.status}). ${text || ''}`);
                    });
                }
                return response.json();
            })
            .then(newAds => {
                // Call appropriate function based on page number
                if (page === 1) {
                    updateCategoryAdsGrid(newAds); // Replace content for page 1
                } else {
                    appendCategoryAdsGrid(newAds); // Append content for subsequent pages
                }
            })
            .catch(error => {
                console.error('Error fetching subcategory ads:', error);
                // Display error message in the grid
                adsGrid.innerHTML = `<p style="text-align: center; color: red; grid-column: 1 / -1; padding: 20px;">Failed to load ads. ${error.message}</p>`;
                showMoreBtn.style.display = 'none'; // Hide button on error
                resultsHeading.textContent = "Error Loading Ads";
                resultsContainer.style.display = 'block'; // Keep container visible to show error
            })
            .finally(() => {
                // Reset "Show More" button state if it's still visible
                if (showMoreBtn.style.display !== 'none') {
                    showMoreBtn.textContent = 'Show More';
                    showMoreBtn.disabled = false;
                }
                loadingOverlay.style.display = 'none'; // Hide loading overlay

                // Scroll to results only on the *first* successful load
                if (page === 1 && adsGrid.querySelector('.ad-card')) {
                    resultsContainer.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
                }
            });
    }


    // --- Removed unused/redundant subcategory handling functions ---
    // function toggleSubcategories(...) - Logic integrated into main click handler
    // function createSubcategoryMarkup(...) - Logic integrated into main click handler
    // function fetchSubcategoryAds(...) - Functionality covered by fetchCategoryAds


    /********************************************************
     *                                                      *
     *           PAGE-SPECIFIC INITIALIZATION               *
     *      (Chat, Image Swap - only on Ad Detail)          *
     *                                                      *
     ********************************************************/

    // --- Ad Detail Page Specific Logic ---
    function initializeAdDetail() {
        const adDetailContainer = document.querySelector('.ad-detail-container');
        if (!adDetailContainer) return; // Only run if we are on ad_detail page

        console.log("Initializing Ad Detail page specific features...");

        // --- Image Gallery Logic ---
        const mainImage = document.getElementById('mainImage');
        const thumbnails = document.querySelectorAll('.thumbnail');
        if (mainImage && thumbnails.length > 0) {
            console.log("Setting up image gallery...");
            let currentMainImageSrc = mainImage.src.split('?')[0]; // Get base src without query params
            thumbnails.forEach(thumb => {
                const thumbBaseSrc = thumb.dataset.src; // Get base src from data attribute
                thumb.src = `${thumbBaseSrc}?t=${Date.now()}`; // Add timestamp for cache busting on load

                thumb.addEventListener('click', function() {
                    const newSrcBase = this.dataset.src; // Base src of clicked thumbnail
                    // Avoid reloading the same image
                    if (currentMainImageSrc === newSrcBase) return;

                    // Fade out effect
                    mainImage.style.transition = 'opacity 0.3s ease-in-out';
                    mainImage.style.opacity = 0.5;

                    // Update src with new timestamp and update tracked base src
                    const newTimestampedSrc = `${newSrcBase}?t=${Date.now()}`;
                    mainImage.src = newTimestampedSrc;
                    currentMainImageSrc = newSrcBase;

                    // Update active thumbnail style
                    thumbnails.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');

                    // Fade in when loaded (or handle error)
                    mainImage.onload = () => { mainImage.style.opacity = 1; };
                    mainImage.onerror = () => { mainImage.style.opacity = 1; console.error("Failed to load image:", newTimestampedSrc); };
                    // Fallback opacity reset in case onload doesn't fire quickly
                    setTimeout(() => { mainImage.style.opacity = 1; }, 400);
                });
            });
        } else {
            console.warn("Image gallery elements (#mainImage, .thumbnail) not found for ad detail.");
        }

        // --- Chat Logic ---
        const sellerIDStr = adDetailContainer?.dataset?.sellerId;
        const adIDStr = adDetailContainer?.dataset?.adId;
        const sellerID = parseInt(sellerIDStr, 10);
        const adID = parseInt(adIDStr, 10);
        var socket = null; // WebSocket connection
        var canChat = true; // Flag to enable/disable chat functionality

        // Get chat UI elements
        const chatButtonElement = document.getElementById('chatButton');
        const chatBoxElement = document.getElementById('chatBox');
        const messageInputElement = document.getElementById('messageInput');
        const messagesDivElement = document.getElementById('messages');
        const sellerStatusElement = document.getElementById('sellerStatus');

        // --- Define Helper Functions (Local Scope) ---

        function openChat() {
            if (!canChat || !chatBoxElement) return;
            chatBoxElement.style.display = "block";

            // Establish WebSocket connection if not already open or connecting
            if (!socket || socket.readyState === WebSocket.CLOSED || socket.readyState === WebSocket.CLOSING) {
                const wsProtocol = window.location.protocol === "https:" ? "wss://" : "ws://";
                const wsURL = wsProtocol + window.location.host + "/ws";
                console.log("Connecting to WebSocket:", wsURL);

                try {
                    socket = new WebSocket(wsURL);

                    socket.onopen = function() {
                        console.log("WebSocket connected");
                        // Optional: fetch conversation history upon opening
                        // fetchConversationHistory();
                        if (sellerStatusElement) fetchUserStatus(sellerID); // Check status on connect
                    };

                    socket.onmessage = function(event) {
                        console.log("WebSocket message received:", event.data);
                        try {
                            var data = JSON.parse(event.data);

                            // Handle different message types
                            if (data.type === "notification") {
                                console.log("Notification:", data.message);
                                // Potentially update UI based on notification, e.g., user status change
                                if (data.event === "user_status_update" && data.user_id === sellerID && sellerStatusElement) {
                                    sellerStatusElement.textContent = data.online ? "Seller Online" : "Seller Offline";
                                    sellerStatusElement.style.color = data.online ? '#ffffff' : '#dcedff'; // Match existing colors
                                }
                                return;
                            }

                            // Process chat messages relevant to this ad
                            if (data.ad_id === adID && messagesDivElement) {
                                var msgElem = document.createElement("div");
                                msgElem.style.marginBottom = '8px';
                                msgElem.style.padding = '6px 10px';
                                msgElem.style.borderRadius = '8px';
                                msgElem.style.maxWidth = '85%';
                                msgElem.style.wordWrap = 'break-word';
                                msgElem.style.clear = 'both'; // Ensures proper stacking
                                msgElem.style.fontSize = '0.9rem';

                                // Format timestamp
                                const messageTime = new Date(data.timestamp || Date.now()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                                // Style based on sender
                                if (data.sender_id === sellerID) { // Message from Seller
                                    msgElem.textContent = data.message;
                                    msgElem.style.background = '#e4e6eb'; // Light grey for received
                                    msgElem.style.color = '#050505';
                                    msgElem.style.float = 'left';
                                    msgElem.setAttribute('title', `Seller - ${messageTime}`);
                                } else { // Message from Current User (You)
                                    msgElem.textContent = data.message;
                                    msgElem.style.background = '#1DBFC1'; // Theme color for sent
                                    msgElem.style.color = 'white';
                                    msgElem.style.float = 'right';
                                     msgElem.setAttribute('title', `You - ${messageTime}`);
                                }

                                messagesDivElement.appendChild(msgElem);
                                // Scroll to the bottom
                                messagesDivElement.scrollTop = messagesDivElement.scrollHeight;
                            } else {
                                console.log("Received message for different ad or messagesDiv missing:", data.ad_id);
                            }
                        } catch (e) {
                            console.error("Failed to parse WebSocket message:", e, event.data);
                        }
                    };

                    socket.onerror = function(error) {
                        console.error("WebSocket Error:", error);
                        // Optionally alert user or update UI
                        // alert("Chat connection error. Please try again.");
                    };

                    socket.onclose = function(event) {
                        console.log("WebSocket closed:", event.code, event.reason);
                        socket = null; // Clear the socket variable
                        // Optionally attempt to reconnect or inform the user
                        if (sellerStatusElement) {
                             sellerStatusElement.textContent = "Chat Disconnected";
                             sellerStatusElement.style.color = '#ffaaaa'; // Indicate disconnection
                        }
                    };

                } catch (e) {
                    console.error("WebSocket connection error:", e);
                    alert("Could not establish chat connection.");
                    chatBoxElement.style.display = "none"; // Hide chatbox on connection failure
                    return;
                }
            } else if (socket.readyState === WebSocket.CONNECTING) {
                console.log("WebSocket is still connecting...");
                // Maybe show a connecting status briefly
            } else if (socket.readyState === WebSocket.OPEN) {
                console.log("WebSocket already open.");
                // Optional: Fetch history if re-opening the box without full reconnect
                // fetchConversationHistory();
                 if (sellerStatusElement) fetchUserStatus(sellerID); // Re-check status
            }
        };

        function sendTyping() {
            // Placeholder for sending a 'typing' indicator if implemented on the backend
            /*
            if (socket && socket.readyState === WebSocket.OPEN) {
                 socket.send(JSON.stringify({ type: 'typing', ad_id: adID, receiver_id: sellerID }));
            }
            */
           // console.log("Typing..."); // Keep console log for debugging if needed
        };

        // Fetches seller status via HTTP endpoint
        function fetchUserStatus(userIdToFetch) {
             if (!sellerStatusElement) return; // Check if status element exists

             // Initial state before fetch
             // sellerStatusElement.textContent = "Checking status...";
             // sellerStatusElement.style.color = '#ccc';

             fetch("/user-status?user_id=" + userIdToFetch)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                 })
                .then(data => {
                    sellerStatusElement.textContent = data.online ? "Seller Online" : "Seller Offline";
                    // Use specific colors for clarity
                    sellerStatusElement.style.color = data.online ? '#adffad' : '#dcedff'; // Light green for online, light blue/grey for offline
                 })
                .catch(err => {
                    console.error("Error fetching seller status:", err);
                    sellerStatusElement.textContent = "Status N/A"; // Indicate error fetching status
                    sellerStatusElement.style.color = '#ffaaaa'; // Reddish for error
                 });
        };


        // --- Check IDs and Assign Global Functions ---
        if (isNaN(sellerID) || isNaN(adID)) {
            console.error("Error: Could not read valid sellerID or adID from data attributes for chat.", { sellerStr: sellerIDStr, adStr: adIDStr });
            canChat = false; // Disable chat functionality
            if (chatButtonElement) {
                // Disable the chat button visually
                chatButtonElement.disabled = true;
                chatButtonElement.style.opacity = 0.6;
                chatButtonElement.style.cursor = 'not-allowed';
                // Update text to indicate unavailability
                const icon = chatButtonElement.querySelector('i');
                chatButtonElement.textContent = ' Chat Unavailable'; // Prepend space for alignment
                if (icon) chatButtonElement.prepend(icon); // Add icon back if it exists
            }
        } else {
             console.log("Chat IDs loaded:", { adID, sellerID });

             // Assign functions called by HTML onclick handlers to the global window object
             // This is necessary because the functions are defined inside DOMContentLoaded scope
             window.toggleChat = function() {
                 if (!canChat || !chatBoxElement) return;
                 if (chatBoxElement.style.display === "none" || chatBoxElement.style.display === "") {
                     openChat(); // Call the local helper function to open/connect
                 } else {
                     chatBoxElement.style.display = "none"; // Simply hide the box
                 }
             };

             window.sendMessage = function() {
                 if (!canChat || !messageInputElement || !socket || socket.readyState !== WebSocket.OPEN) {
                     console.error("Cannot send message: Chat not available or WebSocket not open.");
                      if (!socket || socket.readyState !== WebSocket.OPEN) {
                         alert("Chat connection lost. Please reopen the chat window.");
                         openChat(); // Try to reopen/reconnect
                      }
                     return;
                 }

                 var message = messageInputElement.value.trim();
                 if (!message) return; // Don't send empty messages

                 var msgObj = {
                     ad_id: adID,
                     receiver_id: sellerID, // Send to the seller
                     message: message
                     // timestamp will be added server-side or on reception in this example
                 };

                 try {
                     socket.send(JSON.stringify(msgObj));
                     console.log("Message sent:", msgObj);

                     messageInputElement.value = ""; // Clear input field
                     messageInputElement.focus(); // Keep focus on input

                 } catch (e) {
                     console.error("Error sending message:", e);
                     alert("Failed to send message. Connection might be closed.");
                 }
             };

             // Set up event listeners for elements controlled purely by JS (no onclick in HTML)
             if (messageInputElement) {
                 messageInputElement.oninput = sendTyping; // Calls local helper (currently just logs)
                 messageInputElement.onkeypress = function(event) {
                     // Send message on Enter key press
                     if(event.key === 'Enter') {
                        event.preventDefault(); // Prevent default form submission/newline
                        window.sendMessage(); // Call the globally assigned function
                     }
                 };
             }

             // Initial status check and polling (calls local helper)
             fetchUserStatus(sellerID); // Check status immediately
             setInterval(() => fetchUserStatus(sellerID), 30000); // Poll every 30 seconds (adjust interval as needed)
        }

    } // End initializeAdDetail

    /********************************************************
     *                                                      *
     *         MAIN DOMCONTENTLOADED EVENT LISTENER         *
     *             (Initialization & Core Logic)            *
     *                                                      *
     ********************************************************/
    document.addEventListener('DOMContentLoaded', function() {
      console.log("DOM fully loaded and parsed. Initializing common elements...");

      // --- Common Element References & Initial Setup ---
      const loadingOverlay = document.getElementById('loadingOverlay');
      const filterForm = document.getElementById('filterForm');
      const locationIcon = document.getElementById('locationIcon');
      // const categoryElement = document.getElementById('category'); // For search bar (handled below)
      // const subcategoryElement = document.getElementById('subcategory'); // For search bar (handled below)
      const showMoreBtn = document.getElementById('showMoreBtn'); // Main "Show More" for index/filters
      const mainAdsGridElement = document.querySelector('main.container > section.ads-grid'); // Main ads grid (Index page or Filter results)
      const categoryGrid = document.getElementById('categoryGrid'); // Container for category buttons/wrappers
      // REMOVED: const subcategoryContainer = document.getElementById('subcategoryContainer'); // No longer used
      const categoryShowMoreBtn = document.getElementById('categoryShowMoreBtn'); // Category browse "Show More"
      const categoryAdsGrid = document.getElementById('categoryAdsGrid'); // Category browse results grid
      const categoryResultsContainer = document.getElementById('categoryResultsContainer'); // Container for category results heading+grid+button
      const browseSectionElement = document.querySelector('.category-browse-section'); // The whole category browse section

      // --- Initialize Choices.js for Search Form Selects (if the search form itself exists) ---
      const filterFormForChoices = document.getElementById('filterForm'); // Check for the specific form
      if (filterFormForChoices) {
          console.log("Search form (#filterForm) found. Attempting Choices init for search dropdowns...");
          const categoryElementForSearch = filterFormForChoices.querySelector('#category'); // Find *within* the form
          const subcategoryElementForSearch = filterFormForChoices.querySelector('#subcategory'); // Find *within* the form

          if (categoryElementForSearch && subcategoryElementForSearch) {
             let searchCategorySelect, searchSubcategorySelect; // Use different variable names
             try {
                searchCategorySelect = new Choices(categoryElementForSearch, { searchEnabled: false, itemSelectText: '', position: 'auto', shouldSort: false });
                searchSubcategorySelect = new Choices(subcategoryElementForSearch, { searchEnabled: false, itemSelectText: '', position: 'auto', shouldSort: false });
                console.log("Choices.js initialized for search dropdowns successfully.");

                 // Category change updates Subcategory dropdown (for search bar only)
                 categoryElementForSearch.addEventListener('change', function() {
                     const category = this.value;
                     searchSubcategorySelect.clearStore(); // Clear existing options
                     searchSubcategorySelect.clearInput(); // Clear current selection/input

                     if (category === 'all' || !category) {
                        // If 'All Categories' or no category selected
                        searchSubcategorySelect.setChoices([{ value: 'all', label: 'All Subcategories', selected: true, disabled: false }], 'value', 'label', true);
                        if (!category) {
                            // If no category selected (e.g., placeholder), disable subcategory
                            searchSubcategorySelect.disable();
                            searchSubcategorySelect.setChoices([{ value: '', label: 'Subcategory', selected: true, disabled: true, placeholder: true }], 'value', 'label', true);
                        } else {
                             searchSubcategorySelect.enable(); // Enable for 'All Categories'
                        }
                     } else if (subcategories[category]) {
                         // If a valid category with subcategories is selected
                        searchSubcategorySelect.enable();
                         const items = [
                             { value: '', label: 'Select Subcategory', placeholder: true, disabled: true, selected: true } // Add placeholder first
                         ].concat(
                             subcategories[category].map(sub => ({
                                 value: sub.toLowerCase().replace(/ /g, '_').replace(/&/g, 'and'), // Generate value
                                 label: sub // Use original name as label
                             }))
                         );
                        searchSubcategorySelect.setChoices(items, 'value', 'label', true);
                        // Do NOT setValue here, let the placeholder be selected by default
                     } else {
                         // If category has no subcategories or is invalid
                        searchSubcategorySelect.disable();
                        searchSubcategorySelect.setChoices([{ value: '', label: 'Subcategory', selected: true, disabled: true, placeholder: true }], 'value', 'label', true);
                     }
                     console.log("Base.html: Search subcategory dropdown updated.");
                 });
                 // Trigger change on load IF a category is pre-selected (might be needed if form retains values)
                 // if (categoryElementForSearch.value) {
                 //    categoryElementForSearch.dispatchEvent(new Event('change'));
                 // }

             } catch (error) { console.error("Base.html: Error initializing Choices.js for search form:", error); }
          } else {
              console.log("Base.html: Category/Subcategory select elements NOT found within #filterForm.");
          }
      } else {
           console.log("Base.html: Search form (#filterForm) not found on this page. Skipping Choices init for search.");
      }

      // --- Common Event Listeners (check element existence first) ---

      // Account Dropdown Toggle Logic
      document.querySelectorAll('.dropdown-toggle').forEach(toggle => {
          const parentDropdown = toggle.closest('.account-dropdown'); if (!parentDropdown) return;
          toggle.addEventListener('click', function(event) {
              event.preventDefault(); event.stopPropagation();
              const menus = parentDropdown.querySelectorAll('.dropdown-menu');
              // Close other dropdowns before toggling the current one
              document.querySelectorAll('.account-dropdown .dropdown-menu.show').forEach(openMenu => {
                 // Check if the open menu is NOT inside the currently clicked dropdown's parent
                 if (!parentDropdown.contains(openMenu)) {
                     openMenu.classList.remove('show');
                 }
              });
              // Toggle the menus within the current dropdown
              menus.forEach(menu => menu.classList.toggle('show'));
          });
      });
      // Close dropdowns if clicking outside
      document.addEventListener('click', function(event) {
          if (!event.target.closest('.account-dropdown')) {
             document.querySelectorAll('.account-dropdown .dropdown-menu.show').forEach(menu => menu.classList.remove('show'));
          }
      });

      // Search Form: Location Icon Click Listener
      if (locationIcon) {
          locationIcon.addEventListener('click', function(event) {
              event.preventDefault(); // Prevent any default action
              handleLocationLogic(true); // Get location and show alerts/prompts
          });
      } else { console.log("Location icon element (#locationIcon) not found."); }

      // Search Form: Submission Handler
      if (filterForm) {
          filterForm.addEventListener('submit', function(e) {
              e.preventDefault(); // Prevent default form submission
              if (loadingOverlay) loadingOverlay.style.display = 'block'; // Show loading overlay

              // Reset state for filter results
              currentFilterParams = null;
              currentFilterPage = 1;
              if(categoryResultsContainer) categoryResultsContainer.style.display = 'none'; // Hide category browse results

              const formData = new FormData(this);
              const state = formData.get('state');
              const pincode = formData.get('pincode');
              console.log("Filter submit triggered. Form Data:", Object.fromEntries(formData));

              // Perform forward geocoding only if state and pincode are provided
              let geocodePromise = (state && pincode) ? fetchAndUpdateLatLng(state, pincode) : Promise.resolve({ lat: "", lng: "" });

              geocodePromise.then(({ lat, lng }) => { // Destructure the resolved lat/lng
                  // Update form data *after* geocoding if successful
                  // Note: fetchAndUpdateLatLng already updates the hidden inputs if successful
                  // We just need to ensure the FormData used for the search includes these *potentially* updated values.
                  // Re-creating URLSearchParams from the form *after* the promise resolves ensures this.
                  const searchParams = new URLSearchParams(new FormData(filterForm)); // Use potentially updated form data
                  searchParams.set('page', '1'); // Start at page 1 for new filter
                  currentFilterParams = new URLSearchParams(searchParams); // Store params for subsequent "Show More" clicks
                  currentFilterParams.delete('page'); // Don't store page in base params

                  console.log("Filter API call params:", searchParams.toString());

                  // Update UI to show searching status
                  if(mainAdsGridElement) {
                      mainAdsGridElement.innerHTML = '<p style="text-align: center; grid-column: 1 / -1;">Searching...</p>';
                      mainAdsGridElement.style.display = 'grid'; // Ensure grid is visible even when empty/searching
                  } else {
                      console.warn("Main ads grid not found for filter search status");
                  }
                  if (showMoreBtn) showMoreBtn.style.display = 'none'; // Hide main show more button

                  // Make the fetch request to filter ads
                  return fetch('/filter-ads', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                      body: searchParams.toString()
                  });
              })
              .then(response => {
                  if (!response.ok) {
                      // Try to parse error text from response body
                      return response.text().then(text => {
                          throw new Error(`Filter response error: ${response.statusText} (${response.status}). ${text}`);
                      });
                  }
                  return response.json(); // Parse successful JSON response
              })
              .then(filteredAdsPage1 => {
                  console.log("Received filtered ads (Page 1):", filteredAdsPage1);
                  updateAdsGrid(filteredAdsPage1); // Update the MAIN ads grid with results
              })
              .catch(error => {
                  console.error('Filter process error:', error);
                  // Display error message in the main grid
                  if(mainAdsGridElement) {
                      mainAdsGridElement.innerHTML = `<p style="text-align: center; color: red; grid-column: 1 / -1;">Failed to load ads. ${error.message}</p>`;
                  }
                  if (showMoreBtn) showMoreBtn.style.display = 'none'; // Hide button on error
                  currentFilterParams = null; // Reset filter params on error
              })
              .finally(() => {
                  if (loadingOverlay) loadingOverlay.style.display = 'none'; // Hide loading overlay
              });
          });
      } else { console.log("Filter form element (#filterForm) not found."); }

      // --- Initial Page Setup ---
      // Setup carousels for any ad cards already present on the page (e.g., from server-side render)
      document.querySelectorAll('.carousel').forEach(setupCarousel);
      console.log("Initial carousels setup check done.");

      // Auto-fetch location on page load (useful for categories/search prefill)
      // Pass 'false' to prevent alerts if location fails automatically
      console.log("Attempting auto-fetch location on page load (no alerts)...");
      handleLocationLogic(false);

      // --- Main Pagination ("Show More" for Latest Posts / Filtered Results - Primarily for Index/Main Grid) ---
      if (showMoreBtn && mainAdsGridElement) {
          const initialAdCount = mainAdsGridElement.querySelectorAll('.ad-card').length;
          // Show button only if there might be more pages
          showMoreBtn.style.display = (initialAdCount === 0 || initialAdCount < PAGE_SIZE) ? 'none' : 'block';

          showMoreBtn.addEventListener('click', function() {
              this.textContent = 'Loading...';
              this.disabled = true;
              let fetchUrl, fetchOptions;

              if (currentFilterParams) {
                  // Fetching more FILTERED results
                  currentFilterPage++;
                  const paramsForFetch = new URLSearchParams(currentFilterParams); // Use stored base params
                  paramsForFetch.append('page', currentFilterPage.toString());
                  fetchUrl = '/filter-ads';
                  fetchOptions = {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                      body: paramsForFetch.toString()
                  };
                  console.log(`Fetching FILTERED page ${currentFilterPage}`);
              } else {
                  // Fetching more INITIAL results (Index page default)
                  initialLoadPage++;
                  fetchUrl = `/fetch-ads?page=${initialLoadPage}`;
                  fetchOptions = { method: 'GET' };
                  console.log(`Fetching INITIAL page ${initialLoadPage}`);
              }

              fetch(fetchUrl, fetchOptions)
                  .then(response => {
                      if (!response.ok) {
                          return response.text().then(text => {
                              throw new Error(`Fetch more ads error: ${response.statusText} (${response.status}). ${text}`);
                          });
                      }
                      return response.json();
                  })
                  .then(newAds => {
                      appendAdsToGrid(newAds); // Appends to MAIN grid
                  })
                  .catch(error => {
                      console.error('Error fetching more ads:', error);
                      alert(`Could not load more ads: ${error.message}`);
                      this.style.display = 'none'; // Hide button on error
                  })
                  .finally(() => {
                      // Reset button state only if it wasn't hidden due to error or no more results
                      if (this.style.display !== 'none') {
                          this.textContent = 'Show More';
                          this.disabled = false;
                      }
                  });
          });
      } else {
          console.log("Main Show More button (#showMoreBtn) or main ads grid not found (expected on non-index pages or if initial load had < PAGE_SIZE ads).");
      }


      // --- CATEGORY BROWSE     // --- CATEGORY BROWSE INITIALIZATION & LISTENERS (If elements exist) ---
    // Check for essential elements for the browse section
    if (categoryGrid && browseSectionElement && typeof subcategories === 'object' && subcategories !== null && Object.keys(subcategories).length > 0) {
        console.log("INFO: Prerequisites met. Initializing Category Browse Section.");
        browseSectionElement.style.display = 'block'; // Ensure section is visible

        try {
            // 1. Populate Main Categories with Wrappers
            Object.keys(subcategories).forEach(catKey => {
                const wrapper = document.createElement('div');
                wrapper.className = 'category-wrapper'; // Create wrapper div

                const catButton = document.createElement('button');
                catButton.className = 'category-item';
                catButton.textContent = catKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                catButton.dataset.category = catKey; // Store the original key
                wrapper.appendChild(catButton); // Add button to wrapper

                const subList = document.createElement('div');
                subList.className = 'subcategory-list'; // Container for subcategories for THIS category
                subList.id = `subcategories-for-${catKey}`; // Unique ID if needed later
                subList.style.display = 'none'; // Hide initially
                wrapper.appendChild(subList); // Add sublist container to wrapper

                categoryGrid.appendChild(wrapper); // Add the whole wrapper to the grid
            });
            console.log(`INFO: Successfully added ${Object.keys(subcategories).length} category wrappers.`);

            // 2. Combined Click Listener for Categories and Subcategories (using event delegation on categoryGrid)
            categoryGrid.addEventListener('click', function(event) {

               // --- Handle Category Item Click ---
               if (event.target.classList.contains('category-item')) {
                  const selectedCategoryButton = event.target;
                  const categoryKey = selectedCategoryButton.dataset.category; // Get key from data attribute
                  const wrapper = selectedCategoryButton.closest('.category-wrapper');
                  const targetSubList = wrapper ? wrapper.querySelector('.subcategory-list') : null;

                  if (!categoryKey || !wrapper || !targetSubList) {
                      console.error("ERROR: Could not find category key, wrapper, or sublist for clicked item.", event.target);
                      return;
                  }
                  // console.log(`Category clicked: ${categoryKey}`); // Optional log

                  const isActive = targetSubList.classList.contains('show');

                  // --- First: Hide all *other* open sublists and deactivate their buttons ---
                  categoryGrid.querySelectorAll('.category-wrapper').forEach(otherWrapper => {
                      const otherButton = otherWrapper.querySelector('.category-item');
                      const otherSubList = otherWrapper.querySelector('.subcategory-list');
                      // Check if it's a different wrapper and its sublist is currently shown
                      if (otherWrapper !== wrapper && otherSubList && otherSubList.classList.contains('show')) {
                          otherSubList.classList.remove('show');
                          otherSubList.style.display = 'none';
                          otherSubList.innerHTML = ''; // Clear content when hiding to force repopulation
                          if (otherButton) otherButton.classList.remove('active');
                      }
                  });

                  // --- Second: Toggle the clicked category's sublist ---
                  if (isActive) {
                      // If it was active, hide it & deactivate button
                      targetSubList.classList.remove('show');
                      targetSubList.style.display = 'none';
                      targetSubList.innerHTML = ''; // Clear content
                      selectedCategoryButton.classList.remove('active');

                      // Hide category results section when collapsing the active category
                      if (categoryResultsContainer) categoryResultsContainer.style.display = 'none';
                      if (categoryAdsGrid) categoryAdsGrid.innerHTML = '';
                      if (categoryShowMoreBtn) categoryShowMoreBtn.style.display = 'none';
                      currentSubcategoryFilter = null; // Clear filter

                  } else {
                      // --- Show Logic ---
                      // If it was inactive, activate button, populate (if needed), show it
                      selectedCategoryButton.classList.add('active'); // Activate current button

                      // Populate subcategories only if the list is currently empty
                      if (!targetSubList.innerHTML.trim()) {
                          // Check if data exists for this category key
                          if (subcategories[categoryKey] && Array.isArray(subcategories[categoryKey]) && subcategories[categoryKey].length > 0) {
                              // console.log(`Populating subcategories for ${categoryKey}`); // Optional log
                              subcategories[categoryKey].forEach(subName => {
                                  const subButton = document.createElement('button');
                                  subButton.className = 'subcategory-item';
                                  subButton.textContent = subName;
                                  // Store both subcategory key (formatted) and original parent category key
                                  subButton.dataset.subcategory = subName.toLowerCase().replace(/ /g, '_').replace(/&/g, 'and');
                                  subButton.dataset.parentCategory = categoryKey;
                                  targetSubList.appendChild(subButton);
                              });
                          } else {
                              // Display message if no subcategories found
                              targetSubList.innerHTML = '<p style="color: #777; font-style: italic; width: 100%; text-align: center; padding: 10px 0;">No subcategories available.</p>';
                          }
                      }
                      // Show the list
                      targetSubList.style.display = 'flex'; // Set display to flex (or block if preferred) FIRST
                      // Use a tiny timeout before adding class if animation sometimes doesn't trigger reliably
                      // setTimeout(() => {
                            targetSubList.classList.add('show'); // THEN add class for animation/styling
                      // }, 10);


                       // Hide any previous category results section when opening a new category (before a subcat is clicked)
                      if (categoryResultsContainer) categoryResultsContainer.style.display = 'none';
                      if (categoryAdsGrid) categoryAdsGrid.innerHTML = '';
                      if (categoryShowMoreBtn) categoryShowMoreBtn.style.display = 'none';
                      currentSubcategoryFilter = null; // Clear filter
                  }
               }

               // --- Handle Subcategory Item Click ---
               else if (event.target.classList.contains('subcategory-item')) {
                   const subcatButton = event.target;
                   const subcategoryKey = subcatButton.dataset.subcategory;
                   const parentCategoryKey = subcatButton.dataset.parentCategory; // Get parent category key

                   if (!subcategoryKey || !parentCategoryKey) {
                       console.error("Subcategory or parent category key missing from data attributes.");
                       return;
                   }
                   // console.log(`Subcategory clicked: ${subcategoryKey} under ${parentCategoryKey}`); // Optional log

                   // Optional: Highlight clicked subcategory
                    const parentSubList = subcatButton.closest('.subcategory-list');
                    if(parentSubList) {
                        parentSubList.querySelectorAll('.subcategory-item.active').forEach(activeSub => activeSub.classList.remove('active'));
                        subcatButton.classList.add('active');
                    }


                   // Get location - required for fetching ads
                   const lat = document.getElementById('latInput')?.value;
                   const lng = document.getElementById('lngInput')?.value;

                   // Check if lat/lng are available (they should be if handleLocationLogic ran)
                   if (!lat || !lng) {
                       alert("Location is required to browse by subcategory. Please allow location access or use the location icon in the search bar.");
                       return; // Stop if no location
                   }

                   // Set current filter and reset page for results
                   categoryCurrentPage = 1;
                   currentSubcategoryFilter = { category: parentCategoryKey, subcategory: subcategoryKey };

                   // Fetch ads for the selected subcategory (page 1)
                   fetchCategoryAds(parentCategoryKey, subcategoryKey, lat, lng, 1); // Calls the function to load ads into #categoryResultsContainer
               }
            });


        } catch (error) {
            console.error("ERROR: Failed during category browse section setup:", error);
            if(browseSectionElement) browseSectionElement.style.display = 'none'; // Hide section on error
            console.warn("WARN: Hiding category browse section due to initialization error.");
        }
    } else {
        // Log if prerequisites are not met
        console.log("INFO: Category browse section prerequisites (categoryGrid, browseSectionElement, subcategories object) not met or elements not found. Hiding section.");
        if(browseSectionElement) browseSectionElement.style.display = 'none'; // Hide section if prerequisites fail
    } // End of Category Browse Initialization Check

     // --- Category Results "Show More" Button Listener (If button exists) ---
     // (Keep this section exactly as it was in the previous correct version)
     if (categoryShowMoreBtn) {
         categoryShowMoreBtn.addEventListener('click', function() {
             if (!currentSubcategoryFilter || !currentSubcategoryFilter.category || !currentSubcategoryFilter.subcategory) {
                 console.error("Cannot show more: No valid subcategory filter active.");
                 return;
             }
             categoryCurrentPage++;
             console.log(`Loading category page: ${categoryCurrentPage} for ${currentSubcategoryFilter.subcategory}`);
             const lat = document.getElementById('latInput')?.value;
             const lng = document.getElementById('lngInput')?.value;
             if (!lat || !lng) {
                 alert("Location missing. Cannot load more ads.");
                 this.style.display = 'none';
                 return;
             }
             fetchCategoryAds(currentSubcategoryFilter.category, currentSubcategoryFilter.subcategory, lat, lng, categoryCurrentPage);
         });
     } else {
         console.log("INFO: Category Show More button (#categoryShowMoreBtn) not found (normal if results container isn't visible yet).");
     }
     // --- End Category Results "Show More" ---

     // --- Initialize Page-Specific Features ---
     initializeAdDetail(); // This function checks internally if it's on the ad detail page
     // Add other page-specific initializations here if needed
     // --- End Page-Specific Features ---

}); // End DOMContentLoaded
</script>

<!-- Placeholder for extra page-specific scripts -->
{{ block "scripts_extra" . }}{{ end }}

</body> 
</html> 

